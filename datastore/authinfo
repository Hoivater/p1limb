<h3 class="text-center">Подключение авторизации и регистрации на сайт</h3>

<p>Стандартная авторизация с регистрацией представляет собой пару страниц (страница авторизации: /auth, страница регистрации: /registration, и страница восстановления пароля: /auth/newpassword) и набор кода, сопровождающего страницы. Восстановление пароля происходит через email.</p>



<p>Для того, чтобы появились следующие пути их необходимо прописать в ваш route.php routePublicLimb():</p>


<pre><code data-language = "php">[code]
#модуль регистрации
elseif($route_arr[0] == "destructauth")
{
	setcookie("code", '', -1);
	setcookie("email", '', -1);
	header("Location:/");				
}
elseif($route_arr[0] == "registration")
{
	$html = new Modules\Auth\AuthPage(false);
	$html -> Registration();				
}
elseif($route_arr[0] == "auth")
{
	if(isset($route_arr[1])){
		if($route_arr[1] == "newpassword"){
			$html = new Modules\Auth\AuthPage(false);
			$html -> NewPassword();	
		}
		else
		{
			$html = new Modules\Auth\AuthPage(false);
			$html -> Auth();					
		}
	}
	else
	{
		$html = new Modules\Auth\AuthPage(false);
		$html -> Auth();					
	}	
}
#модуль регистрации
[/code]</code></pre>


<p>После этого станут доступны оба адреса: /auth и /registration. При необходимости отключить один из них по той или иной причине не составляет труда просто удалив их, либо ограничив зарегистрированными пользователями.</p>

<p>Авторизация хранится в cookies в течении дня, если не отмечена галочка "запомнить". В таком случае будет храниться в cookies в течении месяца.</p>

<p>При записи создается пара значений в cookie - email и code, где code - это произвольно генерируемое значение для каждого пользователя - в сессии хранится закешировано в md5, а email - это email пользователя. При совпадении пользователь считается авторизированным.</p>


<p>
	Основной принцип ограничение чего-либо по принципу авторизованности: - узнать авторизацию поьзователя и(или) статус его авторизации; - внести ограничения через if, либо через других операторов. 
	Есть две важных функции, которые помогут ограничить маршруты. 
</p>
<p>1. Проверить получить права пользователя: Control::IsRules(); user - обычный пользователь, admin - администратор</p>
<p>2. Проверить авторизацию пользователя на странице: Control::IsAuth(); true - авторизирован, false - не авторизирован</p>
<p>
	По умолчанию в Limb не удалены элементы проверки на route. Им в классе Route является переменная private $auth. В которую происходит запись через функцию: $this -> auth = Control\Control::IsRules(). Если пользователь авторизирован, то в переменной содержится его статус - user, admin. Если нет - то false </p>
<h4>Ограничения маршрутов</h4>

<pre><code data-language = "php">[code]
#путь только для зарегистрированных пользователей
if($route_arr[0] == "first" && $this -> auth !== false)
{
	$html = new LimbSite\FitrstPage();
}
#путь только для администратора
if($route_arr[0] == "administrator" && $this -> auth == "admin")
{
	$html = new LimbSite\FitrstPage();
}
[/code]</code></pre>

<h4>Права доступа в шаблоне</h4>
<p>По умолчанию в модуле авторизации предусмотрены пару типов разрешений, то есть user, admin, noauth, all. Где user - это любой зарегистрированный пользователь, а admin - соответсвтвенно администратор который имеет свой уровень, дальше com в коде ниже:</p>
<div class = "code_ex">
<pre>
%startuser% 
	Видит любой зарегистрированный пользователь
%enduser%

%startadmin%
	Видит только владелец сайта, администратор
%endadmin%

%startnoauth%
  Код видимый лишь неавторизированным пользователям, скрывается при положительной
  авторизации пользователя
%endnoauth%

%startall%
  Какой-то код, видимый исключительно зарегистрированным пользователям [user и admin]
%endall%

...Какой-то код который видят все
</pre>
</div>
<p>Для замены в шаблоне специальных имен создать класс AuthAccess и воспользоваться методом getResult() (конечно если это необходимо отдельно, ведь это уже включено в функцию вывода каждой страницы Limb, если подключен модуль AUTH, либо самостоятельного созданного и основанного на методе TemplateMaster(), объекта Limb из App\Worker): </p>
<div class = "code_ex">
<pre>
$auth = Base\Control\Control::IsRules();//возвращает admin, user иначе
#говоря, то что содержится напротив авторизированного пользователя в столбце <i>access_user.</i> 
$obj = new Auths\AuthAccess($html, $auth);
$result = $obj -> getResult();
</pre>
</div>

<h3>Стандартные роли и создание своих</h3>
<p>Под ролями будем понимать отношение пользователя к какому-либо уровню доступа. Например предустановленные: 'admin', 'user', 'noauth', 'all'. Admin - открывает доступность для администратора, user - для зарегистрированного пользователя (присваивается при регистрации, изменить можно вручную, либо написав интерфейс для изменения этого параметра в таблице user), noauth - доступно для незарегистрированных пользователей, all - для всех пользователей. </p>
<p>
	Для того, чтобы добавить свои роли достаточно записать их в поле класса AuthAccess после, перечисленных стандартом в массиве $roles:
</p>

<pre><code data-language = "php">[code]
private $roles = ['admin', 'user', 'noauth', 'all'];
[/code]</code></pre>

<p>Класс AuthAccess необходим для работы шаблонизатора в части отсеивания той html части, которую должны видеть лишь определенные круги пользователей.</p>


<pre><code data-language = "html">[code]
% startuser % 
	Видит любой зарегистрированный пользователь
% enduser %

% startadmin %
	Видит только владелец сайта, администратор
% endadmin %

% startnoauth %
  Код видимый лишь неавторизированным пользователям, скрывается при положительной
  авторизации пользователя
% endnoauth %

% startall %
  Какой-то код, видимый исключительно зарегистрированным пользователям [user и admin]
% endall %

...Какой-то код который видят все
[/code]</code></pre>


